// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NEOENGINE_NEO_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_NEOENGINE_NEO_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace Neo {
namespace FlatBuffer {

struct Vector2;

struct Vector3;

struct Vector4;

struct Matrix4x4;

struct Property;
struct PropertyBuilder;

struct Behavior;
struct BehaviorBuilder;

struct Object;
struct ObjectBuilder;

struct Level;
struct LevelBuilder;

struct RPCCall;
struct RPCCallBuilder;

enum PROPERTY_TYPES : int8_t {
  PROPERTY_TYPES_UNKNOWN = 0,
  PROPERTY_TYPES_INTEGER = 1,
  PROPERTY_TYPES_UNSIGNED_INTEGER = 2,
  PROPERTY_TYPES_FLOAT = 3,
  PROPERTY_TYPES_VECTOR2 = 4,
  PROPERTY_TYPES_VECTOR3 = 5,
  PROPERTY_TYPES_VECTOR4 = 6,
  PROPERTY_TYPES_MATRIX4x4 = 7,
  PROPERTY_TYPES_COLOR = 8,
  PROPERTY_TYPES_STRING = 9,
  PROPERTY_TYPES_PATH = 10,
  PROPERTY_TYPES_BOOL = 11,
  PROPERTY_TYPES_LIST = 12,
  PROPERTY_TYPES_MIN = PROPERTY_TYPES_UNKNOWN,
  PROPERTY_TYPES_MAX = PROPERTY_TYPES_LIST
};

inline const PROPERTY_TYPES (&EnumValuesPROPERTY_TYPES())[13] {
  static const PROPERTY_TYPES values[] = {
    PROPERTY_TYPES_UNKNOWN,
    PROPERTY_TYPES_INTEGER,
    PROPERTY_TYPES_UNSIGNED_INTEGER,
    PROPERTY_TYPES_FLOAT,
    PROPERTY_TYPES_VECTOR2,
    PROPERTY_TYPES_VECTOR3,
    PROPERTY_TYPES_VECTOR4,
    PROPERTY_TYPES_MATRIX4x4,
    PROPERTY_TYPES_COLOR,
    PROPERTY_TYPES_STRING,
    PROPERTY_TYPES_PATH,
    PROPERTY_TYPES_BOOL,
    PROPERTY_TYPES_LIST
  };
  return values;
}

inline const char * const *EnumNamesPROPERTY_TYPES() {
  static const char * const names[14] = {
    "UNKNOWN",
    "INTEGER",
    "UNSIGNED_INTEGER",
    "FLOAT",
    "VECTOR2",
    "VECTOR3",
    "VECTOR4",
    "MATRIX4x4",
    "COLOR",
    "STRING",
    "PATH",
    "BOOL",
    "LIST",
    nullptr
  };
  return names;
}

inline const char *EnumNamePROPERTY_TYPES(PROPERTY_TYPES e) {
  if (flatbuffers::IsOutRange(e, PROPERTY_TYPES_UNKNOWN, PROPERTY_TYPES_LIST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPROPERTY_TYPES()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2() {
    memset(static_cast<void *>(this), 0, sizeof(Vector2));
  }
  Vector2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() {
    memset(static_cast<void *>(this), 0, sizeof(Vector3));
  }
  Vector3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vector4() {
    memset(static_cast<void *>(this), 0, sizeof(Vector4));
  }
  Vector4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vector4, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix4x4 FLATBUFFERS_FINAL_CLASS {
 private:
  float entries_[16];

 public:
  Matrix4x4() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix4x4));
  }
  const flatbuffers::Array<float, 16> *entries() const {
    return reinterpret_cast<const flatbuffers::Array<float, 16> *>(entries_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix4x4, 64);

struct Property FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_SIZE = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Neo::FlatBuffer::PROPERTY_TYPES type() const {
    return static_cast<Neo::FlatBuffer::PROPERTY_TYPES>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct PropertyBuilder {
  typedef Property Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Property::VT_NAME, name);
  }
  void add_type(Neo::FlatBuffer::PROPERTY_TYPES type) {
    fbb_.AddElement<int8_t>(Property::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Property::VT_SIZE, size, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Property::VT_DATA, data);
  }
  explicit PropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PropertyBuilder &operator=(const PropertyBuilder &);
  flatbuffers::Offset<Property> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Property>(end);
    return o;
  }
};

inline flatbuffers::Offset<Property> CreateProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Neo::FlatBuffer::PROPERTY_TYPES type = Neo::FlatBuffer::PROPERTY_TYPES_UNKNOWN,
    uint64_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  PropertyBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Property> CreatePropertyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Neo::FlatBuffer::PROPERTY_TYPES type = Neo::FlatBuffer::PROPERTY_TYPES_UNKNOWN,
    uint64_t size = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Neo::FlatBuffer::CreateProperty(
      _fbb,
      name__,
      type,
      size,
      data__);
}

struct Behavior FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BehaviorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PROPERTIES = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BehaviorBuilder {
  typedef Behavior Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Behavior::VT_NAME, name);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>>> properties) {
    fbb_.AddOffset(Behavior::VT_PROPERTIES, properties);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Behavior::VT_DATA, data);
  }
  explicit BehaviorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BehaviorBuilder &operator=(const BehaviorBuilder &);
  flatbuffers::Offset<Behavior> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Behavior>(end);
    return o;
  }
};

inline flatbuffers::Offset<Behavior> CreateBehavior(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BehaviorBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_properties(properties);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Behavior> CreateBehaviorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *properties = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<Neo::FlatBuffer::Property>>(*properties) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Neo::FlatBuffer::CreateBehavior(
      _fbb,
      name__,
      properties__,
      data__);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TRANSFORM = 6,
    VT_CHILDREN = 8,
    VT_BEHAVIORS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Neo::FlatBuffer::Matrix4x4 *transform() const {
    return GetStruct<const Neo::FlatBuffer::Matrix4x4 *>(VT_TRANSFORM);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *>(VT_CHILDREN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>> *behaviors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>> *>(VT_BEHAVIORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<Neo::FlatBuffer::Matrix4x4>(verifier, VT_TRANSFORM) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyOffset(verifier, VT_BEHAVIORS) &&
           verifier.VerifyVector(behaviors()) &&
           verifier.VerifyVectorOfTables(behaviors()) &&
           verifier.EndTable();
  }
};

struct ObjectBuilder {
  typedef Object Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Object::VT_NAME, name);
  }
  void add_transform(const Neo::FlatBuffer::Matrix4x4 *transform) {
    fbb_.AddStruct(Object::VT_TRANSFORM, transform);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>>> children) {
    fbb_.AddOffset(Object::VT_CHILDREN, children);
  }
  void add_behaviors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>>> behaviors) {
    fbb_.AddOffset(Object::VT_BEHAVIORS, behaviors);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Neo::FlatBuffer::Matrix4x4 *transform = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>>> children = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>>> behaviors = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_behaviors(behaviors);
  builder_.add_children(children);
  builder_.add_transform(transform);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const Neo::FlatBuffer::Matrix4x4 *transform = 0,
    const std::vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *children = nullptr,
    const std::vector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>> *behaviors = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<flatbuffers::Offset<Neo::FlatBuffer::Object>>(*children) : 0;
  auto behaviors__ = behaviors ? _fbb.CreateVector<flatbuffers::Offset<Neo::FlatBuffer::Behavior>>(*behaviors) : 0;
  return Neo::FlatBuffer::CreateObject(
      _fbb,
      name__,
      transform,
      children__,
      behaviors__);
}

struct Level FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LevelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAINCAMERANAME = 4,
    VT_OBJECTS = 6
  };
  const flatbuffers::String *mainCameraName() const {
    return GetPointer<const flatbuffers::String *>(VT_MAINCAMERANAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *>(VT_OBJECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAINCAMERANAME) &&
           verifier.VerifyString(mainCameraName()) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           verifier.EndTable();
  }
};

struct LevelBuilder {
  typedef Level Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mainCameraName(flatbuffers::Offset<flatbuffers::String> mainCameraName) {
    fbb_.AddOffset(Level::VT_MAINCAMERANAME, mainCameraName);
  }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>>> objects) {
    fbb_.AddOffset(Level::VT_OBJECTS, objects);
  }
  explicit LevelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LevelBuilder &operator=(const LevelBuilder &);
  flatbuffers::Offset<Level> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Level>(end);
    return o;
  }
};

inline flatbuffers::Offset<Level> CreateLevel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mainCameraName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Object>>> objects = 0) {
  LevelBuilder builder_(_fbb);
  builder_.add_objects(objects);
  builder_.add_mainCameraName(mainCameraName);
  return builder_.Finish();
}

inline flatbuffers::Offset<Level> CreateLevelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mainCameraName = nullptr,
    const std::vector<flatbuffers::Offset<Neo::FlatBuffer::Object>> *objects = nullptr) {
  auto mainCameraName__ = mainCameraName ? _fbb.CreateString(mainCameraName) : 0;
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<Neo::FlatBuffer::Object>>(*objects) : 0;
  return Neo::FlatBuffer::CreateLevel(
      _fbb,
      mainCameraName__,
      objects__);
}

struct RPCCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RPCCallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION = 4,
    VT_ARGUMENTS = 6
  };
  const flatbuffers::String *function() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNCTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *>(VT_ARGUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FUNCTION) &&
           verifier.VerifyString(function()) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           verifier.EndTable();
  }
};

struct RPCCallBuilder {
  typedef RPCCall Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(flatbuffers::Offset<flatbuffers::String> function) {
    fbb_.AddOffset(RPCCall::VT_FUNCTION, function);
  }
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>>> arguments) {
    fbb_.AddOffset(RPCCall::VT_ARGUMENTS, arguments);
  }
  explicit RPCCallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RPCCallBuilder &operator=(const RPCCallBuilder &);
  flatbuffers::Offset<RPCCall> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RPCCall>(end);
    return o;
  }
};

inline flatbuffers::Offset<RPCCall> CreateRPCCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> function = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Neo::FlatBuffer::Property>>> arguments = 0) {
  RPCCallBuilder builder_(_fbb);
  builder_.add_arguments(arguments);
  builder_.add_function(function);
  return builder_.Finish();
}

inline flatbuffers::Offset<RPCCall> CreateRPCCallDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *function = nullptr,
    const std::vector<flatbuffers::Offset<Neo::FlatBuffer::Property>> *arguments = nullptr) {
  auto function__ = function ? _fbb.CreateString(function) : 0;
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<Neo::FlatBuffer::Property>>(*arguments) : 0;
  return Neo::FlatBuffer::CreateRPCCall(
      _fbb,
      function__,
      arguments__);
}

}  // namespace FlatBuffer
}  // namespace Neo

#endif  // FLATBUFFERS_GENERATED_NEOENGINE_NEO_FLATBUFFER_H_
